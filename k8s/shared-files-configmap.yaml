apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-files
  namespace: global-city-streaming
data:
  __init__.py: |
    # Empty init file to make the directory a Python package
  utils.py: |
    import json
    import logging
    from typing import Dict, Any

    def setup_logging(name: str, level: str = "INFO") -> logging.Logger:
        """Set up logging with the specified name and level."""
        logger = logging.getLogger(name)
        logger.setLevel(level)
        
        # Create console handler with formatting
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger

    def parse_json_message(message: str) -> Dict[str, Any]:
        """Parse a JSON message string into a dictionary."""
        try:
            return json.loads(message)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON message: {e}")

    def format_temperature(temp: float) -> str:
        """Format temperature with 1 decimal place."""
        return f"{temp:.1f}Â°C"

    def validate_city_data(data: Dict[str, Any]) -> bool:
        """Validate that the city data contains all required fields."""
        required_fields = ['city', 'country', 'temperature', 'timestamp']
        return all(field in data for field in required_fields)
  weather/__init__.py: |
    from .api import WeatherAPI

    __all__ = ['WeatherAPI']
  weather/api.py: |
    import os
    import requests
    import sys
    import aiohttp
    import asyncio
    from typing import Optional, Dict, Any, List

    class WeatherAPI:
        def __init__(self):
            self.api_key = os.environ.get('WEATHER_API_KEY')
            self.api_url = "https://api.weatherapi.com/v1/current.json"
            self.batch_enabled = False  # Default to sequential processing
            
            if not self.api_key:
                raise ValueError("WEATHER_API_KEY environment variable not set")

        def fetch_city_data(self, city: str) -> Optional[Dict[str, Any]]:
            """
            Fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                response = requests.get(self.api_url, params=query)
                
                if not response.ok:
                    print(f"Error: Weather API request failed with status {response.status_code}", file=sys.stderr)
                    return None
                    
                data = response.json()
                result = self._compose_city_object(data, city)
                return result
                
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None

        async def fetch_city_data_async(self, city: str, session: aiohttp.ClientSession) -> Optional[Dict[str, Any]]:
            """
            Asynchronously fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                async with session.get(self.api_url, params=query) as response:
                    if not response.ok:
                        print(f"Error: Weather API request failed with status {response.status}", file=sys.stderr)
                        return None
                        
                    data = await response.json()
                    result = self._compose_city_object(data, city)
                    return result
                    
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None
        
        def fetch_cities_batch(self, cities: List[str]) -> Dict[str, Dict[str, Any]]:
            """
            Fetch weather data for multiple cities.
            If batch_enabled is True, returns a dictionary of all cities at once.
            If batch_enabled is False (default), yields each city's data as it's processed.
            """
            print(f"fetch_cities_batch called with batch_enabled={self.batch_enabled}", file=sys.stderr)
            if self.batch_enabled:
                # Batch mode: process all cities at once and return dict
                results = {}
                for city in cities:
                    print(f"Fetching data for {city} in batch mode", file=sys.stderr)
                    data = self.fetch_city_data(city)
                    print(f"Data for {city}: {data}", file=sys.stderr)
                    if data:  # Only add if data is not None
                        results[city] = data
                print(f"Batch results: {results}", file=sys.stderr)
                return results
            else:
                # Sequential mode: yield each city's data as it's processed
                for city in cities:
                    data = self.fetch_city_data(city)
                    yield city, data
                
        def _compose_city_object(self, api_response: Dict[str, Any], city: str) -> Dict[str, Any]:
            """
            Compose a standardized city object from the API response.
            """
            try:
                # Extract latitude and longitude from the API response
                lat = api_response['location']['lat']
                lon = api_response['location']['lon']
                
                result = {
                    'city': city,
                    'country': api_response['location']['country'],
                    'continent': api_response['location']['tz_id'].split("/")[0],
                    'temperatureCelsius': api_response['current']['temp_c'],
                    'latitude': lat,
                    'longitude': lon
                }
                return result
            except Exception as e:
                print(f"Error composing city object for {city}: {str(e)}", file=sys.stderr)
                return None
  monitoring/exec-settings.txt: |
    -- -- - EXECUTION SETTINGS AND METRICS - -- -- 

    KAFKA PRODUCER METRICS:
    - Total Cities Processed: 89 (84 static + 5 dynamic)
    - Request Interval: 0.01 seconds
    - Messages per Second: 100.00 (89 cities / 0.89 seconds cycle)

    FLINK PROCESSOR METRICS:
    - Batch Size: 300 records
    - Batch Interval: 200ms
    - Maximum Theoretical Processing Rate: 1500.00 records/second
    - Actual Processing Rate: 100.00 records/second (limited by producer rate)
    - Sample Duration: 5 seconds
    - Max Retries: 5

    POSTGRES DATABASE:
    - Actual Insertion Rate: 100.00 records/second (matches input rate from Kafka)

    Note: All rates are theoretical maximums under ideal conditions. Actual rates may vary due to network latency, processing overhead, and system factors. 