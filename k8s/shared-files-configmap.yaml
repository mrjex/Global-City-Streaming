apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-files
  namespace: global-city-streaming
data:
  __init__.py: |
    # Empty init file to make the directory a Python package
  utils.py: |
    import json
    import logging
    from typing import Dict, Any

    def setup_logging(name: str, level: str = "INFO") -> logging.Logger:
        """Set up logging with the specified name and level."""
        logger = logging.getLogger(name)
        logger.setLevel(level)
        
        # Create console handler with formatting
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger

    def parse_json_message(message: str) -> Dict[str, Any]:
        """Parse a JSON message string into a dictionary."""
        try:
            return json.loads(message)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON message: {e}")

    def format_temperature(temp: float) -> str:
        """Format temperature with 1 decimal place."""
        return f"{temp:.1f}Â°C"

    def validate_city_data(data: Dict[str, Any]) -> bool:
        """Validate that the city data contains all required fields."""
        required_fields = ['city', 'country', 'temperature', 'timestamp']
        return all(field in data for field in required_fields)
  weather.__init__.py: |
    from .api import WeatherAPI

    __all__ = ['WeatherAPI']
  weather.api.py: |
    import os
    import requests
    import sys
    import aiohttp
    import asyncio
    from typing import Optional, Dict, Any, List

    class WeatherAPI:
        def __init__(self):
            self.api_key = os.environ.get('WEATHER_API_KEY')
            self.api_url = "https://api.weatherapi.com/v1/current.json"
            self.batch_enabled = False  # Default to sequential processing
            
            if not self.api_key:
                raise ValueError("WEATHER_API_KEY environment variable not set")

        def fetch_city_data(self, city: str) -> Optional[Dict[str, Any]]:
            """
            Fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                response = requests.get(self.api_url, params=query)
                
                if not response.ok:
                    print(f"Error: Weather API request failed with status {response.status_code}", file=sys.stderr)
                    return None
                    
                data = response.json()
                result = self._compose_city_object(data, city)
                return result
                
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None

        async def fetch_city_data_async(self, city: str, session: aiohttp.ClientSession) -> Optional[Dict[str, Any]]:
            """
            Asynchronously fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                async with session.get(self.api_url, params=query) as response:
                    if not response.ok:
                        print(f"Error: Weather API request failed with status {response.status}", file=sys.stderr)
                        return None
                        
                    data = await response.json()
                    result = self._compose_city_object(data, city)
                    return result
                    
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None
        
        def fetch_cities_batch(self, cities: List[str]) -> Dict[str, Dict[str, Any]]:
            """
            Fetch weather data for multiple cities.
            If batch_enabled is True, returns a dictionary of all cities at once.
            If batch_enabled is False (default), yields each city's data as it's processed.
            """
            print(f"fetch_cities_batch called with batch_enabled={self.batch_enabled}", file=sys.stderr)
            if self.batch_enabled:
                # Batch mode: process all cities at once and return dict
                results = {}
                for city in cities:
                    print(f"Fetching data for {city} in batch mode", file=sys.stderr)
                    data = self.fetch_city_data(city)
                    print(f"Data for {city}: {data}", file=sys.stderr)
                    if data:  # Only add if data is not None
                        results[city] = data
                print(f"Batch results: {results}", file=sys.stderr)
                return results
            else:
                # Sequential mode: yield each city's data as it's processed
                for city in cities:
                    data = self.fetch_city_data(city)
                    yield city, data
                
        def _compose_city_object(self, api_response: Dict[str, Any], city: str) -> Dict[str, Any]:
            """
            Compose a standardized city object from the API response.
            """
            try:
                # Extract latitude and longitude from the API response
                lat = api_response['location']['lat']
                lon = api_response['location']['lon']
                
                result = {
                    'city': city,
                    'country': api_response['location']['country'],
                    'continent': api_response['location']['tz_id'].split("/")[0],
                    'temperatureCelsius': api_response['current']['temp_c'],
                    'latitude': lat,
                    'longitude': lon
                }
                return result
            except Exception as e:
                print(f"Error composing city object for {city}: {str(e)}", file=sys.stderr)
                return None
  weather.city_coordinates.py: |
    #!/usr/bin/env python3
    import sys
    import json
    import os
    import importlib.util
    import pathlib

    # Dynamically import the api module from the same directory
    current_dir = pathlib.Path(__file__).parent
    api_path = current_dir / "api.py"
    spec = importlib.util.spec_from_file_location("api", api_path)
    api = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(api)
    WeatherAPI = api.WeatherAPI

    def get_city_coordinates(cities):
        weather_api = WeatherAPI()
        weather_api.batch_enabled = True
        
        print(f"Fetching data for {len(cities)} cities", file=sys.stderr)
        
        city_data = {}
        
        print("Fetching data for each city individually", file=sys.stderr)
        for city in cities:
            data = weather_api.fetch_city_data(city)
            if data:
                city_data[city] = data
                print(f"Added coordinates for {city}", file=sys.stderr)
        
        print(json.dumps(city_data))
        return city_data

    if __name__ == "__main__":
        if len(sys.argv) < 2:
            print(json.dumps({"error": "No cities provided"}))
            sys.exit(1)
        
        cities = sys.argv[1:]
        get_city_coordinates(cities)
  country-codes.json: |
    {
      "afghanistan": "AF",
      "albania": "AL",
      "algeria": "DZ",
      "andorra": "AD",
      "angola": "AO",
      "argentina": "AR",
      "armenia": "AM",
      "australia": "AU",
      "austria": "AT",
      "azerbaijan": "AZ",
      "bahrain": "BH",
      "bangladesh": "BD",
      "belarus": "BY",
      "belgium": "BE",
      "bhutan": "BT",
      "bolivia": "BO",
      "bosnia and herzegovina": "BA",
      "brazil": "BR",
      "bulgaria": "BG",
      "cambodia": "KH",
      "cameroon": "CM",
      "canada": "CA",
      "chile": "CL",
      "china": "CN",
      "colombia": "CO",
      "croatia": "HR",
      "cuba": "CU",
      "cyprus": "CY",
      "czech republic": "CZ",
      "czechia": "CZ",
      "denmark": "DK",
      "ecuador": "EC",
      "egypt": "EG",
      "england": "GB",
      "estonia": "EE",
      "ethiopia": "ET",
      "finland": "FI",
      "france": "FR",
      "georgia": "GE",
      "germany": "DE",
      "greece": "GR",
      "holland": "NL",
      "hungary": "HU",
      "iceland": "IS",
      "india": "IN",
      "indonesia": "ID",
      "iran": "IR",
      "iraq": "IQ",
      "ireland": "IE",
      "israel": "IL",
      "italy": "IT",
      "japan": "JP",
      "jordan": "JO",
      "kazakhstan": "KZ",
      "kenya": "KE",
      "kuwait": "KW",
      "latvia": "LV",
      "lebanon": "LB",
      "libya": "LY",
      "liechtenstein": "LI",
      "lithuania": "LT",
      "luxembourg": "LU",
      "madagascar": "MG",
      "malaysia": "MY",
      "maldives": "MV",
      "malta": "MT",
      "mexico": "MX",
      "monaco": "MC",
      "mongolia": "MN",
      "montenegro": "ME",
      "morocco": "MA",
      "nepal": "NP",
      "netherlands": "NL",
      "new zealand": "NZ",
      "nigeria": "NG",
      "north korea": "KP",
      "north macedonia": "MK",
      "norway": "NO",
      "oman": "OM",
      "pakistan": "PK",
      "panama": "PA",
      "paraguay": "PY",
      "peru": "PE",
      "philippines": "PH",
      "poland": "PL",
      "portugal": "PT",
      "qatar": "QA",
      "romania": "RO",
      "russia": "RU",
      "saudi arabia": "SA",
      "serbia": "RS",
      "singapore": "SG",
      "slovakia": "SK",
      "slovenia": "SI",
      "south africa": "ZA",
      "south korea": "KR",
      "spain": "ES",
      "sri lanka": "LK",
      "sweden": "SE",
      "switzerland": "CH",
      "syria": "SY",
      "taiwan": "TW",
      "tajikistan": "TJ",
      "thailand": "TH",
      "tunisia": "TN",
      "turkey": "TR",
      "turkmenistan": "TM",
      "uae": "AE",
      "uk": "GB",
      "ukraine": "UA",
      "united arab emirates": "AE",
      "united kingdom": "GB",
      "united states": "US",
      "usa": "US",
      "uruguay": "UY",
      "uzbekistan": "UZ",
      "vatican city": "VA",
      "venezuela": "VE",
      "vietnam": "VN",
      "yemen": "YE"
    }
  countryCities.sh: |
    #!/bin/bash

    # Debug output redirected to stderr so it doesn't interfere with JSON output
    debug() {
        echo "$1" >&2
    }

    debug "=== SCRIPT START ==="
    debug "Testing basic output"
    debug "Current directory: $(pwd)"
    debug "Script arguments: $@"

    # Step 1: Get the country code for the given country
    COUNTRY="$1"
    debug "Input country: $COUNTRY"

    # Get country code from JSON file
    debug "Getting country code..."
    COUNTRY_CODE=$(echo "$COUNTRY" | tr '[:upper:]' '[:lower:]' | xargs | jq -r --arg country "$COUNTRY" '. | to_entries | .[] | select(.key | ascii_downcase == ($country | ascii_downcase)) | .value' /app/city-api/config/country-codes.json)
    debug "Extracted country code: '$COUNTRY_CODE'"

    if [ -z "$COUNTRY_CODE" ]; then
        debug "Error: Failed to get country code"
        exit 1
    fi

    # Get number of cities from configuration
    debug "Getting number of cities from configuration..."
    CITIES_LIMIT=$(yq '.services.cityApi.numberOfCitiesForSelectedCountry' /app/configuration.yml)
    debug "Number of cities to fetch: $CITIES_LIMIT"

    # Store the curl response in a variable
    debug "Making API request for country code: $COUNTRY_CODE..."
    RESPONSE=$(curl -X GET "https://wft-geo-db.p.rapidapi.com/v1/geo/cities?countryIds=$COUNTRY_CODE&limit=$CITIES_LIMIT&sort=-population&types=CITY" \
      -H "X-RapidAPI-Host: wft-geo-db.p.rapidapi.com" \
      -H "X-RapidAPI-Key: $GEODB_CITIES_API_KEY")

    debug "Raw API Response:"
    debug "$RESPONSE"

    # Extract cities into an array and get count
    debug "Extracting cities..."
    CITIES=$(echo "$RESPONSE" | jq -r '.data[].city' | tr '\n' '|')
    CITY_COUNT=$(echo "$CITIES" | tr '|' '\n' | grep -v '^$' | wc -l)
    debug "Found $CITY_COUNT cities to process"

    # Get the capital city (first city in response)
    CAPITAL_CITY=$(echo "$RESPONSE" | jq -r '.data[0].city')
    debug "Capital city: $CAPITAL_CITY"

    # Get the description for this capital city from the JSON file
    DESCRIPTION_KEY="$COUNTRY, $CAPITAL_CITY"
    debug "Looking up description for key: $DESCRIPTION_KEY"

    # First try to get description from city-edits.yml
    CAPITAL_DESCRIPTION=$(yq ".countries[\"$DESCRIPTION_KEY\"].description" /app/city-api/config/city-edits.yml)
    debug "Description from yml: $CAPITAL_DESCRIPTION" 