apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-files
  namespace: global-city-streaming
data:
  __init__.py: |
    # Empty init file to make the directory a Python package
  utils.py: |
    import json
    import logging
    from typing import Dict, Any

    def setup_logging(name: str, level: str = "INFO") -> logging.Logger:
        """Set up logging with the specified name and level."""
        logger = logging.getLogger(name)
        logger.setLevel(level)
        
        # Create console handler with formatting
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger

    def parse_json_message(message: str) -> Dict[str, Any]:
        """Parse a JSON message string into a dictionary."""
        try:
            return json.loads(message)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON message: {e}")

    def format_temperature(temp: float) -> str:
        """Format temperature with 1 decimal place."""
        return f"{temp:.1f}Â°C"

    def validate_city_data(data: Dict[str, Any]) -> bool:
        """Validate that the city data contains all required fields."""
        required_fields = ['city', 'country', 'temperature', 'timestamp']
        return all(field in data for field in required_fields)
  weather.__init__.py: |
    from .api import WeatherAPI

    __all__ = ['WeatherAPI']
  weather.api.py: |
    import os
    import requests
    import sys
    import aiohttp
    import asyncio
    from typing import Optional, Dict, Any, List

    class WeatherAPI:
        def __init__(self):
            self.api_key = os.environ.get('WEATHER_API_KEY')
            self.api_url = "https://api.weatherapi.com/v1/current.json"
            self.batch_enabled = False  # Default to sequential processing
            
            if not self.api_key:
                raise ValueError("WEATHER_API_KEY environment variable not set")

        def fetch_city_data(self, city: str) -> Optional[Dict[str, Any]]:
            """
            Fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                response = requests.get(self.api_url, params=query)
                
                if not response.ok:
                    print(f"Error: Weather API request failed with status {response.status_code}", file=sys.stderr)
                    return None
                    
                data = response.json()
                result = self._compose_city_object(data, city)
                return result
                
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None

        async def fetch_city_data_async(self, city: str, session: aiohttp.ClientSession) -> Optional[Dict[str, Any]]:
            """
            Asynchronously fetch weather data for a city.
            Returns a standardized city object or None if the request fails.
            """
            try:
                query = {'key': self.api_key, 'q': city, 'aqi': 'yes'}
                async with session.get(self.api_url, params=query) as response:
                    if not response.ok:
                        print(f"Error: Weather API request failed with status {response.status}", file=sys.stderr)
                        return None
                        
                    data = await response.json()
                    result = self._compose_city_object(data, city)
                    return result
                    
            except Exception as e:
                print(f"Error fetching data for {city}: {str(e)}", file=sys.stderr)
                return None
        
        def fetch_cities_batch(self, cities: List[str]) -> Dict[str, Dict[str, Any]]:
            """
            Fetch weather data for multiple cities.
            If batch_enabled is True, returns a dictionary of all cities at once.
            If batch_enabled is False (default), yields each city's data as it's processed.
            """
            print(f"fetch_cities_batch called with batch_enabled={self.batch_enabled}", file=sys.stderr)
            if self.batch_enabled:
                # Batch mode: process all cities at once and return dict
                results = {}
                for city in cities:
                    print(f"Fetching data for {city} in batch mode", file=sys.stderr)
                    data = self.fetch_city_data(city)
                    print(f"Data for {city}: {data}", file=sys.stderr)
                    if data:  # Only add if data is not None
                        results[city] = data
                print(f"Batch results: {results}", file=sys.stderr)
                return results
            else:
                # Sequential mode: yield each city's data as it's processed
                for city in cities:
                    data = self.fetch_city_data(city)
                    yield city, data
                
        def _compose_city_object(self, api_response: Dict[str, Any], city: str) -> Dict[str, Any]:
            """
            Compose a standardized city object from the API response.
            """
            try:
                # Extract latitude and longitude from the API response
                lat = api_response['location']['lat']
                lon = api_response['location']['lon']
                
                result = {
                    'city': city,
                    'country': api_response['location']['country'],
                    'continent': api_response['location']['tz_id'].split("/")[0],
                    'temperatureCelsius': api_response['current']['temp_c'],
                    'latitude': lat,
                    'longitude': lon
                }
                return result
            except Exception as e:
                print(f"Error composing city object for {city}: {str(e)}", file=sys.stderr)
                return None
  weather.city_coordinates.py: |
    #!/usr/bin/env python3
    import sys
    import json
    import os
    import importlib.util
    import pathlib

    # Dynamically import the api module from the same directory
    current_dir = pathlib.Path(__file__).parent
    api_path = current_dir / "api.py"
    spec = importlib.util.spec_from_file_location("api", api_path)
    api = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(api)
    WeatherAPI = api.WeatherAPI

    def get_city_coordinates(cities):
        weather_api = WeatherAPI()
        weather_api.batch_enabled = True
        
        print(f"Fetching data for {len(cities)} cities", file=sys.stderr)
        
        city_data = {}
        
        print("Fetching data for each city individually", file=sys.stderr)
        for city in cities:
            data = weather_api.fetch_city_data(city)
            if data:
                city_data[city] = data
                print(f"Added coordinates for {city}", file=sys.stderr)
        
        print(json.dumps(city_data))
        return city_data

    if __name__ == "__main__":
        if len(sys.argv) < 2:
            print(json.dumps({"error": "No cities provided"}))
            sys.exit(1)
        
        cities = sys.argv[1:]
        get_city_coordinates(cities) 